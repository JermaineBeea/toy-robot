Composition
We use composition to construct objects that have a different purpose than those of the parts.

Take a car as an example. It is an object composed of many different objects. It is made up of wheel objects and an engine object and so on. The engine object is also made up of other objects such as spark plugs and valves, etc. Now, we can’t drive an engine, but we can drive a car. So, the car object has a different purpose than the individual objects from which it is composed.

We can also use the wheel object to make other objects, not just cars. For example, we can use the wheel object to make a trailer to hitch to a car.

Using objects in this way offers opportunity for re-use. Composition takes advantage of the opportunity for re-use.

Composition is one of the most powerful design techniques in software development. It is very highly valued because it leads to simpler designs, higher testability and lower barrier to reasoning about the problem and solution. Make a sincere effort to understand and apply composition, and you will be a better developer for it.

What makes up a Robot object?
Let’s look at what the Robot class encapsulates.

Robot.java
public class Robot {
    //...snip...
    private int positionX;
    private int positionY;
    private String currentDirection;
    private String status;
    private String name;
    //...snip...
}
We notice that Robot objects need to know about its X position and Y position, its last known status, the direction it is facing and, lastly, its name. Interestingly, it’s X and Y position almost always appears together in code.

Robot.java
public class Robot {
    //...snip...
    private boolean isPositionAllowed(int newX, int newY){                                              
        return MIN_X <= newX && newX <= MAX_X
                && MIN_Y <= newY && newY <= MAX_Y;
    }

    private boolean updatePosition(int nrSteps){
        int newY = positionY;                                                                      
        int newX = positionX;

        if ("NORTH" == currentDirection) {
            newY = newY + nrSteps;
        }

        if (isPositionAllowed(newX, newY)){
            positionX = newX;                                                                      
            positionY = newY;
            return true;
        }
        return false;
    }
    //...snip...
}
Whenever, we are working with X, we seem to be working with Y too.
…​ and here.
…​ and here.
If we think about it carefully, Position is an abstraction in our model. It is a location in the world. Therefore, the following are all positions:

the current location of the Robot object

the location of the Robot after it has moved

the top right corner of the world - X: 200 and Y: 200

the top left corner of the world - X: -200 and Y: 200

the bottom right corner of the world - X: 200 and Y: -200

the bottom left corner of the world - X: -200 and Y: -200

the centre of the world - X: 0 and Y: 0

So, the Robot object is made up of, amongst other things, a few positions:

It’s current position

The four corners of its world

The centre of its world

Let’s create a new class Position and then refactor Robot so that it is composed of a the above Position objects.

Introducing the Position object
Create the test class PositionTest and add in the following code.

PositionTest.java
    @Test
    public void shouldKnowXandY() {
        Position p = new Position(10, 20);
        assertEquals(10, p.getX());
        assertEquals(20, p.getY());

    }
Now create the class Position with just enough code to get everything to compile.

Position.java
public class Position {
    public Position(int x, int y) {

    }

    public int getX() {
        return 0;
    }

    public int getY() {
        return 0;
    }
}
Run the tests and it should fail.

Now let’s make the test pass.

Position.java
public class Position {
    private final int x;
    private final int y;

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}
Run the tests and it should pass.

Now let’s wire up Robot to use the Position object.

Robot.java
public class Robot {
    private static final List<String> VALID_COMMANDS = Arrays.asList("off", "help", "forward");

    private static int MIN_Y = -200, MAX_Y = 200;
    private static int MIN_X = -100, MAX_X = 100;

    private static final Position CENTRE = new Position(0,0);                                           

    private Position position;                                                                          
    private String currentDirection;
    private String status;
    private String name;

    public Robot(String name) {
        this.name = name;
        this.status = "Ready";
        this.position = CENTRE;                                                                         
        this.currentDirection = "NORTH";
    }

    public String getStatus() {
        return this.status;
    }

    public int getPositionX() {
        return this.position.getX();                                                                    
    }

    public int getPositionY() {                                                                         
        return this.position.getY();
    }

    public String getCurrentDirection() {
        return this.currentDirection;
    }

    public boolean isValidCommand(String commandInput){
        String[] args = commandInput.strip().split(" ");
        String command = args[0].trim().toLowerCase();
        return VALID_COMMANDS.contains(command);
    }

    public boolean handleCommand(String commandInput){
        if (!isValidCommand(commandInput)) {
           this.status = "I am not programmed to: " + commandInput;
           return false;
        }

        String[] args = commandInput.strip().split(" ");
        String command = args[0].trim().toLowerCase();

        switch (command){
            case "off":
                this.status = "Shutting down";
                break;
            case "help":
                this.status = doHelp();
                break;
            case "forward":
                this.status = doForward(Integer.parseInt(args[1]));
                break;
            default:
                this.status = "I am not programmed for: " + command;
        }
        return true;
    }



    private String doHelp() {
        return "I can understand these commands:\n" +
                "OFF  - Shut down robot\n" +
                "HELP - provide information about commands\n" +
                "FORWARD - move forward by specified number of steps, e.g. 'FORWARD 10'";
    }


    private boolean isPositionAllowed(int newX, int newY){
        return MIN_X <= newX && newX <= MAX_X
                && MIN_Y <= newY && newY <= MAX_Y;
    }

    private boolean updatePosition(int nrSteps){
        int newX = this.position.getX();
        int newY = this.position.getY();

        if ("NORTH".equals(this.currentDirection)) {
            newY = newY + nrSteps;
        }

        if (isPositionAllowed(newX, newY)){
            this.position = new Position(newX, newY);                                                   
            return true;
        }
        return false;
    }

    private String doForward(int nrSteps){
        if (updatePosition(nrSteps)){
            return "Moved forward by "+nrSteps+" steps.";
        } else {
            return "Sorry, I cannot go outside my safe zone.";
        }
    }

    @Override
    public String toString() {
       return "[" + this.position.getX() + "," + this.position.getY() + "] "                            
               + "{" + this.currentDirection + "} "
               + this.name + "> " + this.status;
    }
}
This is the special Position object representing the centre of the world.
We replaced the individual properties for x and y with a Position object.
We position the robot at the centre of the world.
We delegate the retrieval of the x position to the Position object.
Ditto for Y. Note that we should be returning a position object instead of integers but making this change right now will break the tests in RobotTest. So, let’s hold back and make that change next. Remember our principle of small, safe steps.
Create a new Position object and set the private property to reference it. Note that we do not update the value of X and Y in the actual Position object. More on this in the discussion on The Value-Object Pattern
Finally, we ask the Position object for the X and Y values to report in the toString() method.
Run all the tests and they should pass.

The Value-Object Pattern
Notice that we declared the properties in Position as final, e.g. private final int x. In Java, the keyword final means that the variable cannot be changed once it is assigned a value.

In the case of Position, it makes sense! A position is a fixed location in the robot world. The robot can move to different positions, but a position can never be changed. If we want the robot to move to a different position, then we must give the robot a new Position object.

Also notice that whenever need the update the position of the robot, we create a new Position object and reference it in the position property of the Robot object. We never update the values of X and Y in the Position object currently being referenced.

We say that Position is immutable — it cannot change its values.

There are many times that we come across the need for immutable objects. It’s so common that we have a pattern to implement it known as the Value Object pattern. It’s name makes sense: we are interested in its values!

So Position implements the value object pattern because:

it constructs itself from all the values it needs; i.e. it uses a fully qualified constructor public Position(int x, int y).

it allows its values to be read via public int get() and public int getY().

it never allows its values to be changed because it declares its properties as final.

Using composition in your design does not mean that you must use the value object pattern. You can compose objects from other objects without using the value object pattern. We use the value object pattern to model immutable objects.

Enhancing the Position Value Object
Now let’s change RobotTest to be aware of Position objects and not X and Y.

Check if two positions are equal
If we look at RobotTest.java we see that we check the position of the robot by comparing to X and Y.

Robot.java
    @Test
    void initialPosition() {
        Robot robot = new Robot("CrashTestDummy");
        assertEquals(0, robot.getPositionX());
        assertEquals(0, robot.getPositionY());
        assertEquals("NORTH", robot.getCurrentDirection());
    }
Position objects should determine if they are equal. We can assume that two positions are equal if their respective X and Y values are the same.

Let’s change Position to check if it is equal to another Position object.

PositionTest.java
    @Test
    public void equality() {
        assertEquals(new Position(-44, 63), new Position(-44, 63));
        assertNotEquals(new Position(-44, 63), new Position(0, 63));
        assertNotEquals(new Position(-44, 63), new Position(-44, 0));
        assertNotEquals(new Position(-44, 63), new Position(0, 0));
    }
Run the test and it should fail. This is not surprising because Position is using the default equals() method on its base class Object.

Let’s implement our own equals() method. This time, we will take a bit more care than we did for Hangman.

Position.java
public class Position {
    //...snip...
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Position position = (Position) o;

        if (x != position.x) return false;
        return y == position.y;
    }

    public boolean isIn(Position topLeft, Position bottomRight) {
        boolean withinTop = this.y <= topLeft.getY();
        boolean withinBottom = this.y >= bottomRight.getY();
        boolean withinLeft = this.x >= topLeft.getX();
        boolean withinRight = this.x <= bottomRight.getX();
        return withinTop && withinBottom && withinLeft && withinRight;
    }
    //...snip...
}
Now let’s update RobotTest to check equality of Position objects.

RobotTest.java
    @Test
    void initialPosition() {
        Robot robot = new Robot("CrashTestDummy");
        assertEquals(Robot.CENTRE, robot.getPosition());
        assertEquals("NORTH", robot.getCurrentDirection());
    }
Now, the test code won’t compile because the code it needs does not exist yet, so let’s attend to that.

Robot.java
public class Robot {
    //...snip...
    public static final Position CENTRE = new Position(0,0);                                            

    //...snip...
    public Position getPosition() {                                                                     
        return null;
    }
}
The test needs to know the CENTRE, and it is useful for any other calling code too. So we changed the access level for this constant from private to public.
This method simply returns a null. Importantly, we have not deleted the existing getX() and getY() methods because other tests and code depends on that. Be patient, and deliberate! We will delete those methods when we are ready.
Run the tests and it should fail.

Now make the change to pass the tests. It’s a small change.

Robot.java
public class Robot {
    //...snip...
    public Position getPosition() {
        return this.position;
    }
}
Run the tests and they should pass.

Use Position.equals() in all tests
The code below shows the changes to several tests that checked for equality of two positions. For convenience, we are showing all tests in one snippet. Do NOT make all changes at once. Change one test at a time, run all tests, and make sure that all tests pass before moving on to the next test.

RobotTest.java
    @Test
    void forward() {
        Robot robot = new Robot("CrashTestDummy");
        assertTrue(robot.handleCommand("forward 10"));
        Position expectedPosition = new Position(Robot.CENTRE.getX(), Robot.CENTRE.getY() + 10);
        assertEquals(expectedPosition, robot.getPosition());
        assertEquals("Moved forward by 10 steps.", robot.getStatus());
    }

    @Test
    void forwardforward() {
        Robot robot = new Robot("CrashTestDummy");
        assertTrue(robot.handleCommand("forward 10"));
        assertTrue(robot.handleCommand("forward 5"));
        assertEquals("Moved forward by 5 steps.", robot.getStatus());
    }

    @Test
    void tooFarForward() {
        Robot robot = new Robot("CrashTestDummy");
        assertTrue(robot.handleCommand("forward 1000"));
        assertEquals(Robot.CENTRE, robot.getPosition());
        assertEquals("Sorry, I cannot go outside my safe zone.", robot.getStatus());
    }
Notice how we use Robot.CENTRE as an offset for the expected position. This is a good move. Should the Robot change its value of CENTRE then our tests have a better chance of not breaking.

Check if a position is within a rectangular region
In Robot.java we check that the robot does not move outside the boundaries of the world.

Robot.java
public class Robot {
    //...snip...
    private boolean isPositionAllowed(int newX, int newY){
        return MIN_X <= newX && newX <= MAX_X
                && MIN_Y <= newY && newY <= MAX_Y;
    }
    //...snip...
}
So, we do need to find out if a position is within a rectangular region.

We can easily imagine a rectangular region described by its top left corner position and its bottom right corner position. If we draw vertical and horizontal lines from these positions, they will intersect at the top right and bottom left positions. So, we are able to find the four corner positions of a rectangle from two diagonally opposite positions.

From this, we can program the Position object to figure out whether it is within the rectangular region or not.

Let’s write a test and initial code for this behaviour.

PositionTest
    @Test
    public void insideRectangularRegion() {
        Position topLeft = new Position(-20, 20);
        Position bottomRight = new Position(20,-20);
        assertTrue((new Position(10,10)).isIn(topLeft, bottomRight), "should be inside");
        assertFalse((new Position(10,30)).isIn(topLeft, bottomRight), "should be beyond top boundary");
        assertFalse((new Position(10,-30)).isIn(topLeft, bottomRight), "should be beyond bottom boundary");
        assertFalse((new Position(30,10)).isIn(topLeft, bottomRight), "should be beyond right boundary");
        assertFalse((new Position(-30,10)).isIn(topLeft, bottomRight), "should be beyond left boundary");
    }
Position.java
public class Position {
    //...snip...
    public boolean isIn(Position topRight, Position bottomLeft) {
        return false;
    }
}
Run the tests and they should fail.

Now let’s write the code to check if the position is inside the rectangle.

Position.Java
public class Position {
   //...snip...
    public boolean isIn(Position topLeft, Position bottomRight) {
        boolean withinTop = this.y <= topLeft.getY();
        boolean withinBottom = this.y >= bottomRight.getY();
        boolean withinLeft = this.x >= topLeft.getX();
        boolean withinRight = this.x <= bottomRight.getX();
        return withinTop && withinBottom && withinLeft && withinRight;
    }
   //...snip...
}
Run the tests and they should pass.

We could have written the code to eliminate the different boolean variables. However, using the boolean variables makes the code a lot more readable.

Now we can change the Robot code to use Position objects isIn() method.

Robot.java
public class Robot {
   //...snip...
    private final Position TOP_LEFT = new Position(-100,100);
    private final Position BOTTOM_RIGHT = new Position(100,-200);
   //...snip...
    private boolean updatePosition(int nrSteps){
        int newX = this.position.getX();
        int newY = this.position.getY();

        if ("NORTH".equals(this.currentDirection)) {
            newY = newY + nrSteps;
        }

        Position newPosition = new Position(newX, newY);
        if (newPosition.isIn(TOP_LEFT,BOTTOM_RIGHT)){
            this.position = newPosition;
            return true;
        }
        return false;
    }
   //...snip...
}
Run the tests and they should pass.

Clean up Robot
Now that we have refactored Robot to use composition with the Position object, we can clean up all unused methods and private variables.

Change Robot.java to remove getPositionX(), getPositionY(), MIN_X, MIN_Y, MAX_X, MAX_Y.

Make sure that you run your tests and that all tests pass.

Code it yourself
Now that you have learned about composition and the value object pattern, code the following on your own.

Change Robot by using composition to introduce an object for the direction that the robot is facing. The code in Robot.java should be something like"

public class Robot {
    //...snip...
    private Direction currentDirection;
    //...snip...
    public Robot(String name) {
        //...snip...
        currentDirection = Direction.NORTH;
    }
    //...snip...
    private boolean updatePosition(int nrSteps) {
        //...snip...
        if (Direction.NORTH.equals(currentDirection)) {
            newY = newY + nrSteps;
        }
        //...snip...
    }
    //...snip...
}
Remember to do this using TDD and make sure that all your tests pass.

TIP:Use a Java enum for the Direction.

You will need to have the code for Direction in place in order to continue with Inheritance.

A Ubiquitous Language
Ubqiutuous means found everywhere. When say that we prefer to use a ubiquitous language in our models, then we are commiting to being consistent in our naming and vocabulary. We use the same terminology in our code, in sketches, in comments, in documentation and in conversation. The key is consistency and that reduces misunderstanding.

For example, we agree to use the phrase Shopping Cart to represent a virtual cart of products that will be checked on in an online store app. Then, we should not loosely refer to it as Basket. That may mean something else to another person and create confusion. Worse still is we talk about Shopping Cart but program Basket to mean the same thing. This causes confusion amongst the team and customer for whom the system is being built.

Reflection
We changed the design of Robot to use composition by introducing the Position object.

The Position object implemented the Value Object design pattern.

Notice how we reasoned about what makes up a robot and what it should do. In doing so, we modelled the solution using the vocabulary of the robots and related objects. This is known as using a Ubiquitous Language. If there is one thing that you should always strive for, it is using a ubiquitous language.

Here is what our domain model for the Robot game looks like. By domain model, we mean the class diagram of the domain for problem being solved.